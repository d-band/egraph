/* eslint-env mocha */
const assert = require('power-assert')
const Graph = require('../../graph')
const EdgeConcentrationTransformer = require('../../transformer/edge-concentration')
const newbery = require('../../transformer/edge-concentration/newbery')
const mbea = require('../../transformer/edge-concentration/mbea')

describe('EdgeConcentrationTransformer', () => {
  describe('transform(g)', () => {
    it('returns transformed graph', () => {
      const u1 = 0
      const u2 = 1
      const v1 = 2
      const v2 = 3
      const w1 = 4
      const w2 = 5
      const graph = new Graph()
        .addVertex(u1)
        .addVertex(u2)
        .addVertex(v1)
        .addVertex(v2)
        .addVertex(w1)
        .addVertex(w2)
        .addEdge(u1, v1)
        .addEdge(u1, v2)
        .addEdge(u1, w1)
        .addEdge(u1, w2)
        .addEdge(u2, v1)
        .addEdge(u2, v2)
        .addEdge(u2, w1)
        .addEdge(u2, w2)
        .addEdge(v1, w1)
        .addEdge(v1, w2)
        .addEdge(v2, w1)
        .addEdge(v2, w2)
      const transformed = new EdgeConcentrationTransformer().transform(graph)
      assert.equal(transformed.inDegree(u1), 0)
      assert.equal(transformed.outDegree(u1), 1)
      assert.equal(transformed.inDegree(u2), 0)
      assert.equal(transformed.outDegree(u2), 1)
      assert.equal(transformed.inDegree(v1), 1)
      assert.equal(transformed.outDegree(v1), 1)
      assert.equal(transformed.inDegree(v2), 1)
      assert.equal(transformed.outDegree(v2), 1)
      assert.equal(transformed.inDegree(w1), 2)
      assert.equal(transformed.outDegree(w1), 0)
      assert.equal(transformed.inDegree(w2), 2)
      assert.equal(transformed.outDegree(w2), 0)
    })

    it('returns transformed graph', () => {
      const [u1, u2, u3, u4] = [0, 1, 2, 3]
      const [v1, v2, v3, v4] = [4, 5, 6, 7]
      const graph = new Graph()
        .addVertex(u1)
        .addVertex(u2)
        .addVertex(u3)
        .addVertex(u4)
        .addVertex(v1)
        .addVertex(v2)
        .addVertex(v3)
        .addVertex(v4)
        .addEdge(u1, v1)
        .addEdge(u1, v2)
        .addEdge(u2, v1)
        .addEdge(u2, v2)
        .addEdge(u3, v3)
        .addEdge(u3, v4)
        .addEdge(u4, v3)
        .addEdge(u4, v4)
      const transformed = new EdgeConcentrationTransformer().transform(graph)
      assert.equal(transformed.inDegree(u1), 0)
      assert.equal(transformed.outDegree(u1), 1)
      assert.equal(transformed.inDegree(u2), 0)
      assert.equal(transformed.outDegree(u2), 1)
      assert.equal(transformed.inDegree(v1), 1)
      assert.equal(transformed.outDegree(v1), 0)
      assert.equal(transformed.inDegree(v2), 1)
      assert.equal(transformed.outDegree(v2), 0)
      assert.equal(transformed.inDegree(u3), 0)
      assert.equal(transformed.outDegree(u3), 1)
      assert.equal(transformed.inDegree(u4), 0)
      assert.equal(transformed.outDegree(u4), 1)
      assert.equal(transformed.inDegree(v3), 1)
      assert.equal(transformed.outDegree(v3), 0)
      assert.equal(transformed.inDegree(v4), 1)
      assert.equal(transformed.outDegree(v4), 0)
    })

    it('returns transformed graph', () => {
      const [u1, u2, u3, u4, u5] = [0, 1, 2, 3, 4]
      const [v1, v2, v3, v4, v5] = [5, 6, 7, 8, 9]
      const graph = new Graph()
        .addVertex(u1)
        .addVertex(u2)
        .addVertex(u3)
        .addVertex(u4)
        .addVertex(u5)
        .addVertex(v1)
        .addVertex(v2)
        .addVertex(v3)
        .addVertex(v4)
        .addVertex(v5)
        .addEdge(u1, v1)
        .addEdge(u1, v2)
        .addEdge(u1, v3)
        .addEdge(u2, v1)
        .addEdge(u2, v2)
        .addEdge(u2, v3)
        .addEdge(u3, v1)
        .addEdge(u3, v2)
        .addEdge(u3, v3)
        .addEdge(u3, v4)
        .addEdge(u3, v5)
        .addEdge(u4, v3)
        .addEdge(u4, v4)
        .addEdge(u4, v5)
        .addEdge(u5, v3)
        .addEdge(u5, v4)
        .addEdge(u5, v5)
      const transformed = new EdgeConcentrationTransformer().transform(graph)
      assert.equal(transformed.inDegree(u1), 0)
      assert.equal(transformed.outDegree(u1), 1)
      assert.equal(transformed.inDegree(u2), 0)
      assert.equal(transformed.outDegree(u2), 1)
      assert.equal(transformed.inDegree(u3), 0)
      assert.equal(transformed.outDegree(u3), 2)
      assert.equal(transformed.inDegree(u4), 0)
      assert.equal(transformed.outDegree(u4), 1)
      assert.equal(transformed.inDegree(u5), 0)
      assert.equal(transformed.outDegree(u5), 1)
      assert.equal(transformed.inDegree(v1), 1)
      assert.equal(transformed.outDegree(v1), 0)
      assert.equal(transformed.inDegree(v2), 1)
      assert.equal(transformed.outDegree(v2), 0)
      assert.equal(transformed.inDegree(v3), 2)
      assert.equal(transformed.outDegree(v3), 0)
      assert.equal(transformed.inDegree(v4), 1)
      assert.equal(transformed.outDegree(v4), 0)
      assert.equal(transformed.inDegree(v4), 1)
      assert.equal(transformed.outDegree(v4), 0)
    })
  })
})

describe('newbery(g, h1, h2)', () => {
  it('returns edge concentrations', () => {
    const h1 = [0, 1, 2]
    const h2 = [3, 4, 5, 6, 7, 8, 9, 10, 11]
    const [u1, u2, u3] = h1
    const [v1, v2, v3, v4, v5, v6, v7, v8, v9] = h2
    const graph = new Graph()
      .addVertex(u1)
      .addVertex(u2)
      .addVertex(u3)
      .addVertex(v1)
      .addVertex(v2)
      .addVertex(v3)
      .addVertex(v4)
      .addVertex(v5)
      .addVertex(v6)
      .addVertex(v7)
      .addVertex(v8)
      .addVertex(v9)
      .addEdge(u1, v1)
      .addEdge(u1, v2)
      .addEdge(u1, v3)
      .addEdge(u1, v4)
      .addEdge(u1, v5)
      .addEdge(u1, v6)
      .addEdge(u1, v7)
      .addEdge(u2, v1)
      .addEdge(u2, v2)
      .addEdge(u2, v3)
      .addEdge(u2, v4)
      .addEdge(u2, v5)
      .addEdge(u2, v6)
      .addEdge(u2, v7)
      .addEdge(u2, v8)
      .addEdge(u2, v9)
      .addEdge(u3, v3)
      .addEdge(u3, v4)
      .addEdge(u3, v5)
      .addEdge(u3, v6)
      .addEdge(u3, v7)
      .addEdge(u3, v8)
      .addEdge(u3, v9)

    const result = newbery(graph, h1, h2)
    assert.deepEqual(result, [
      { source: [ 0, 2, 1 ], target: [ 5, 6, 7, 8, 9 ] },
      { source: [ 0, 1 ], target: [ 3, 4 ] },
      { source: [ 1, 2 ], target: [ 10, 11 ] }
    ])
  })
})

describe('mbea(g, h1, h2)', () => {
  it('returns edge concentrations', () => {
    const h1 = [0, 1, 2]
    const h2 = [3, 4, 5, 6, 7, 8, 9, 10, 11]
    const [u1, u2, u3] = h1
    const [v1, v2, v3, v4, v5, v6, v7, v8, v9] = h2
    const graph = new Graph()
      .addVertex(u1)
      .addVertex(u2)
      .addVertex(u3)
      .addVertex(v1)
      .addVertex(v2)
      .addVertex(v3)
      .addVertex(v4)
      .addVertex(v5)
      .addVertex(v6)
      .addVertex(v7)
      .addVertex(v8)
      .addVertex(v9)
      .addEdge(u1, v1)
      .addEdge(u1, v2)
      .addEdge(u1, v3)
      .addEdge(u1, v4)
      .addEdge(u1, v5)
      .addEdge(u1, v6)
      .addEdge(u1, v7)
      .addEdge(u2, v1)
      .addEdge(u2, v2)
      .addEdge(u2, v3)
      .addEdge(u2, v4)
      .addEdge(u2, v5)
      .addEdge(u2, v6)
      .addEdge(u2, v7)
      .addEdge(u2, v8)
      .addEdge(u2, v9)
      .addEdge(u3, v3)
      .addEdge(u3, v4)
      .addEdge(u3, v5)
      .addEdge(u3, v6)
      .addEdge(u3, v7)
      .addEdge(u3, v8)
      .addEdge(u3, v9)

    const result = mbea(graph, h1, h2)
    assert.deepEqual(result, [
      { source: [ 1, 2 ], target: [ 5, 6, 7, 8, 9, 10, 11 ] }
    ])
  })
})
